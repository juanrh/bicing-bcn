package org.collprod.bicingbcn;

import java.io.ByteArrayInputStream;
import java.io.Serializable;
import java.util.ArrayList;

import javax.annotation.Nullable;

import org.apache.metamodel.DataContext;
import org.apache.metamodel.DataContextFactory;
import org.apache.metamodel.data.DataSet;
import org.apache.metamodel.data.Row;
import org.apache.metamodel.query.CompiledQuery;
import org.apache.metamodel.query.Query;
import org.apache.metamodel.schema.Column;
import org.apache.metamodel.schema.Table;
import org.xml.sax.InputSource;

import com.google.auto.value.AutoValue;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Splitter;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

/**
 * Quick and dirty pseudo DAO for bicing data, lots of things can be improved, but the idea is:  
 * - parse() is the only method of the implied interface
 * - BicingStationDao.Value is the model/value class
 * - this class also implements the contract imposed by parse
 * 
 * TODO: put the contract interface in a separate class, and implement here renaming to BicingStationDaoImpl
 * */
public class BicingStationDao implements Serializable {
	
//	/**
//	 * Data context used to parse the data
//	 * */
//	private DataContext bicingDataContext;
	
	// generated by Eclipse
	private static final long serialVersionUID = 6335397659147272320L;
	
	private CompiledQuery updatetimeCompiledQuery;
	private Column updatetimeColumn;
	
	private CompiledQuery stationsCompiledQuery;
	private Column idColumn;
	private Column latColumn;
	private Column longColumn;
	private Column streetColumn;
	private Column heightColumn;
	private Column streetNumberColumn;
	private Column nearbyStationListColumn;
	private Column statusColumn;
	private Column slotsColumn;
	private Column bikesColumn;
		
	public BicingStationDao() {
		this.updatetimeCompiledQuery = null;
		this.updatetimeColumn = null;
		
		this.stationsCompiledQuery = null;
		this.idColumn = null;
		this.latColumn = null;
		this.longColumn = null;
		this.streetColumn = null;
		this.heightColumn = null;
		this.streetNumberColumn = null;
		this.nearbyStationListColumn = null;
		this.statusColumn = null;
		this.slotsColumn = null;
		this.bikesColumn = null;
	}
	
	@AutoValue
	public static abstract class Value implements Serializable {
		// generated by Eclipse
		private static final long serialVersionUID = 8581922474241143038L;
		
		Value() {}
		public static Value create(long updatetime, int id, double latitude,
				double longitude, String street, int height, int streetNumber,
				ArrayList<Integer> nearbyStationList, String status, int slots,
				int bikes) {
	        return new AutoValue_BicingStationDao_Value(updatetime, id, latitude,
					longitude, street, height, streetNumber, nearbyStationList, status, 
					slots, bikes);
	      }
		public abstract long updatetime();
		public abstract int id();
		public abstract double latitude();
		public abstract double longitude();
		public abstract String street();
		public abstract int height();
		public abstract int streetNumber();
		// NOTE: it's essential to use ArrayList instead of List, otherwise this class
		// won't be Serializable and thus NotSerializableException when used in Window operations
		public abstract ArrayList<Integer> nearbyStationList();
		public abstract String status();
		public abstract int slots();
		public abstract int bikes();
	}
	
	private void buildStationsQuery(DataContext bicingData) {
		Table stationsTable = bicingData.getTableByQualifiedLabel("station");
		this.idColumn = stationsTable.getColumnByName("id");
		this.latColumn = stationsTable.getColumnByName("lat");
		this.longColumn = stationsTable.getColumnByName("long");
		this.streetColumn = stationsTable.getColumnByName("street");
		this.heightColumn = stationsTable.getColumnByName("height");
		this.streetNumberColumn = stationsTable.getColumnByName("streetNumber");
		this.nearbyStationListColumn = stationsTable.getColumnByName("nearbyStationList");
		this.statusColumn = stationsTable.getColumnByName("status");
		this.slotsColumn = stationsTable.getColumnByName("slots");
		this.bikesColumn = stationsTable.getColumnByName("bikes");
		Query stationsQuery = bicingData.query().from(stationsTable).select(idColumn)
				.and(latColumn).and(longColumn).and(streetColumn).and(heightColumn)
				.and(streetNumberColumn).and(nearbyStationListColumn).and(statusColumn)
				.and(slotsColumn).and(bikesColumn).toQuery();
		this.stationsCompiledQuery = bicingData.compileQuery(stationsQuery);
	}
	
	private CompiledQuery getStationsQuery(DataContext bicingData) {
		// initialized with the first file parsed, assuming the same schema for
		// the rest of the files to come
		if (this.stationsCompiledQuery == null) {
			this.buildStationsQuery(bicingData);
		}
		return this.stationsCompiledQuery ;
	}
	
	private void buildUpdatetimeQuery(DataContext bicingData) {
		Table updatetimeTable = bicingData.getTableByQualifiedLabel("updatetime");
		this.updatetimeColumn = updatetimeTable.getColumnByName("updatetime"); 
		Query updatetimeQuery = bicingData.query().from(updatetimeTable).select(updatetimeColumn).toQuery();
		this.updatetimeCompiledQuery = bicingData.compileQuery(updatetimeQuery);
	}
	
	private CompiledQuery getupdatetimeQuery(DataContext bicingData) {
		// initialized with the first file parsed, assuming the same schema for
		// the rest of the files to come
		if (this.updatetimeCompiledQuery == null) {
			this.buildUpdatetimeQuery(bicingData);
		}
		return this.updatetimeCompiledQuery;
	}
	
	/**
	 * - If streetNumber is absent (i.e. tag <streetNumber></streetNumber>) then -1 is used for this field
	 * - If height is absent then 0 is used as default
	 * 
	 * NOTE: we are parsing the bicing XML as-is, therefore the updatetime must be converted from
	 * seconds to milliseconds here, not only in the Storm parser
	 * */
	public Iterable<Value> parse(String bicingFileContents) {
		// Load bicing XML string
		DataContext bicingData = DataContextFactory.createXmlDataContext(new InputSource(new ByteArrayInputStream(bicingFileContents.getBytes())), 
				"bicing_data", true);
		
		// get update time
		DataSet updatetimeResults = bicingData.executeQuery(this.getupdatetimeQuery(bicingData));
			// move to first result
		updatetimeResults.next();
		Row updatetimeRow = updatetimeResults.getRow();
		final long updateTime = Long.parseLong(updatetimeRow.getValue(this.updatetimeColumn).toString()) * 1000L;
		updatetimeResults.close();

		// get data for each station, add the update time, and construct the corresponding values
		DataSet stationsResults = bicingData.executeQuery(this.getStationsQuery(bicingData));
		return FluentIterable
				.from(stationsResults)
				.transform(new Function<Row, Value>(){
					@Override
					@Nullable
					public Value apply(@Nullable Row stationsRow) {
						return Value.create(updateTime, 
								Integer.parseInt(stationsRow.getValue(BicingStationDao.this.idColumn).toString()),
								Double.parseDouble(stationsRow.getValue(BicingStationDao.this.latColumn).toString()), 
								Double.parseDouble(stationsRow.getValue(BicingStationDao.this.longColumn).toString()),
								stationsRow.getValue(BicingStationDao.this.streetColumn).toString(),
								Integer.parseInt(Optional.fromNullable(stationsRow.getValue(BicingStationDao.this.heightColumn))
										 .or("0").toString()),
								Integer.parseInt(Optional.fromNullable(stationsRow.getValue(BicingStationDao.this.streetNumberColumn))
														 .or("-1").toString()),
								Lists.newArrayList(Iterables.transform(
										Splitter.on(",").split(stationsRow.getValue(BicingStationDao.this.nearbyStationListColumn).toString()), 
										new Function<String, Integer>() {
											@Override
											@Nullable
											public Integer apply(@Nullable String intStr) {
												return Integer.parseInt(intStr);
											}
								})),
								stationsRow.getValue(BicingStationDao.this.statusColumn).toString(),
								Integer.parseInt(stationsRow.getValue(BicingStationDao.this.slotsColumn).toString()),
								Integer.parseInt(stationsRow.getValue(BicingStationDao.this.bikesColumn).toString())
								);
					}});
		// note stationsResult is not closed		
	}
}
