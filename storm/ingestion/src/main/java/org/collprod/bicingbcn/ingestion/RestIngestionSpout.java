package org.collprod.bicingbcn.ingestion;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.fluent.Request;
import org.collprod.bicingbcn.ingestion.tsparser.TimeStampParser;

import backtype.storm.spout.SpoutOutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseRichSpout;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Values;

import com.google.auto.value.AutoValue;
import com.google.common.base.Stopwatch;
import com.google.common.math.LongMath;

/**
 * @author Juan Rodriguez Hortala <juan.rodriguez.hortala@gmail.com>
 * 
 * This spout has an inmutable configuration as a SourceRequestRefreshrate object per data source, and a
 * mutable state as the stopwatches and timestamps arrays. That mutable state could be persisted in some
 * store like e.g. Redis with RDB snapshots (as it's small and local to each spout instance), but that 
 * is not needed because if the state is lost and the spout restarted that only affects the first
 * call to nextTuple(), which maybe would download a file twice, but then the later calls would be ok 
 * */
public class RestIngestionSpout extends BaseRichSpout {
	
	// package private to allow access from other components
	static final String CONTENT_FIELD = "CONTENT_FIELD";  
	static final String DATASOURCE_ID = "DATASOURCE_ID"; 
	
	// Auto generated by Eclipse
	private static final long serialVersionUID = -3787506061156020464L;
	private static final String REDIS_KEY_PREFIX = RestIngestionSpout.class.getName();
	
	private SpoutOutputCollector collector;
	
	/**
	 * Tuples will be emitted with this refresh rate in miliseconds, which corresponds to the 
	 * greatest common divisor for the set of refresh rates for all sources
	 * 
	 * Using miliseconds as that is the resolution of storm Utils.sleep()
	 * */
	private long refreshRate;
	
	/**
	 * Configuration for each data source
	 * */
	private SourceRequestRefreshrate[] assignedDatasourcesConfs;

	 
	/**
	 * For each data source it contains a Stopwatch that counts the number of miliseconds
	 * since the last request to the service associated to the data source.
	 * 
	 * This variable is aligned with assignedDatasourcesConfs in the sense that the Stopwatch
	 * at position i correspond to the configuration at position i at assignedDatasourcesConfs
	 * (hence both arrays have the same size)
	 * */
	private Stopwatch[] stopwatches;
	
	/**
	 * For each data source it contains the timestamp of the last file downloaded, or null if nothing
	 * was downloaded yet during the like of this  
	 * */
	private Long [] timestamps;

	// AutoValue doesn't support private nested classes
	@AutoValue
	static abstract class SourceRequestRefreshrate {
		SourceRequestRefreshrate() {}
		public static SourceRequestRefreshrate create(String datasourceId, Request request, float refreshRate) {
	        return new AutoValue_RestIngestionSpout_SourceRequestRefreshrate(datasourceId, request, refreshRate);
	      }
		public abstract String datasourceId();
	    public abstract Request request();
	    public abstract float refreshRate();
	}

	
	/**
	 * Find out which datasources correspond to this spout get the relevant configuration data 
	 * 
	 * @return a HashMap<String, UrlRefreshrate> object with the relevant configuration data, the key for
	 * each entry is the datasource id
	 * @throws RuntimeException if no datasource is assigned to this spout, which happens when there are more
	 * spout instances than data souces
	 * */
	private static SourceRequestRefreshrate [] getAssignedDatasources(Map conf, TopologyContext context) {
		// number of spouts
		int spoutSize = context.getComponentTasks(context.getThisComponentId()).size();
		// id for this spout
		int thisTaskIndex = context.getThisTaskIndex();
	    Map<String, String> datasourcesConfigurations = (Map<String, String>) conf.get(IngestionTopology.DATASOURCE_CONF_KEY);
	    
	    List<SourceRequestRefreshrate> assignedDatasourcesConfs = new LinkedList<SourceRequestRefreshrate>();
		int i = 0;
		for (Map.Entry<String, String> datasourceConf : datasourcesConfigurations.entrySet()) {
			if (i % spoutSize == thisTaskIndex) {
				Configuration newProperties;
				try {
					newProperties = IngestionTopology.deserializeConfiguration(datasourceConf.getValue());
				} catch (ConfigurationException ce) {
					System.err.println("Error parsing properties for datasource: " + ce.getMessage());
					ce.printStackTrace();
					throw new RuntimeException(ce);
				}
				assignedDatasourcesConfs.add(SourceRequestRefreshrate.create(datasourceConf.getKey(), 
																			 Request.Get(newProperties.getString("datasource_url")),
																			 newProperties.getFloat("refresh_rate")));
			}
			i++;
		}
	  		
		if (assignedDatasourcesConfs.size() == 0) {
			throw new RuntimeException("This spout is not responsible for consuming any service");
		}
		
		return assignedDatasourcesConfs.toArray(new SourceRequestRefreshrate[assignedDatasourcesConfs.size()]);
	}
	
			
	@Override
	public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {	
		// store collector to be able to emit later
		this.collector = collector;
		
		// Find out which data sources correspond to this spout and store the relevant configuration
		// data at this.assignedDatasourcesConfs
		this.assignedDatasourcesConfs = getAssignedDatasources(conf, context);
		
		// refreshRate should be the greatest common divisor for the set of refresh rates for all sources
		// source rates are floats in seconds, here we convert to miliseconds and round
		this.refreshRate = Math.round(this.assignedDatasourcesConfs[0].refreshRate() * 1000);
		for (int i = 1; i < this.assignedDatasourcesConfs.length; i++) {
			this.refreshRate = LongMath.gcd(this.refreshRate, Math.round(this.assignedDatasourcesConfs[i].refreshRate() * 1000));
		}
		

	}

	@Override
	public void nextTuple() {
		// Note Util.sleep accepts miliseconds
		
		
		// FIXME currently hardcoded and for just one source
		Request req = Request.Get("http://wservice.viabicing.cat:80/getstations.php?v=1");
		try {
			String content = req.execute().returnContent().asString();
			System.out.println(content);
			try {
				TimeStampParser timeStampParser = (TimeStampParser) Class.forName("org.collprod.bicingbcn.ingestion.tsparser.BicingBCNTimeStampParser").newInstance();
				Long timestamp = timeStampParser.apply(content);
				System.out.println(timestamp);
			} catch (Exception e) {
				// FIXME consider the 3 exception types
			}
			// Bad server leads to IOException
			// String noContentBarServer = Request.Get("http://wservice.viabicing.cato:80/getstations.php?v=1").execute().returnContent().asString();

			// Bad resource URL in right server leads to ClientProtocolException
			// String noContentBadPath = Request.Get("http://wservice.viabicing.cat:80/getstationsasdasd.php?v=1").execute().returnContent().asString();


		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		//				webServiceClient = ClientBuilder.newClient();
		//				WebTarget webTarget = webServiceClient.target("http://wservice.viabicing.cat:80/getstations.php?v=1");


		// TODO download file

		// TODO get timestamp and emit only if new, using the <name of the source>+timestamp as id
		// TODO raise an error is parsing returns null


		this.collector.emit(new Values("adsad")); 	// FIXME

	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer declarer) {
		declarer.declare(new Fields(CONTENT_FIELD));
	}



}
