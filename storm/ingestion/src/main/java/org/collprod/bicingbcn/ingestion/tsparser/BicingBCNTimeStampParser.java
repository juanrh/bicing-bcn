package org.collprod.bicingbcn.ingestion.tsparser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Optional;

public class BicingBCNTimeStampParser implements TimeStampParser {

	// generated by Eclipse
	private static final long serialVersionUID = 5708504756672256358L;
	
	private final static Logger LOGGER = LoggerFactory.getLogger(BicingBCNTimeStampParser.class);
	private static final Pattern TIMESTAMP_PATTERN = Pattern.compile("<updatetime><!\\[CDATA\\[(\\d+)\\]\\]></updatetime>");
	// nice resource: http://www.regexplanet.com/advanced/java/index.html
	@Override
	public Optional<Long> apply(String data) {
		/*
		 * Just match the <updatetime> tag with a regexp
		 * */
		Matcher matcher = TIMESTAMP_PATTERN.matcher(data);
		String exceptionMsg = "";
		if (matcher.find()) {
			try {
				// convert to milliseconds
				return Optional.of(Long.parseLong(matcher.group(1)) * 1000);
			} catch (IllegalStateException ise) {
				exceptionMsg = ise.getMessage();
			} catch (IndexOutOfBoundsException iobe) {
				exceptionMsg = iobe.getMessage();
			}
		}
		LOGGER.warn("Cannot parse timestamp for data " + data + 
						exceptionMsg == "" ? "" : ("\n:" + exceptionMsg));
		// No match
		return Optional.absent();
	}
	

}
